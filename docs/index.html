<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HowManyFucks - Web Demo</title>
    <style>
        :root {
            --cell-size: 25px;
        }

        html, body {
            overscroll-behavior: none;
        }

        body {
            font-family: 'Courier New', monospace;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        
        .container {
            background-color: #2d2d2d;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #ff6b6b;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #3a3a3a;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            margin-bottom: 5px;
            color: #ccc;
            font-weight: bold;
        }
        
        select, input, button {
            padding: 8px;
            border: 2px solid #555;
            border-radius: 4px;
            background-color: #4a4a4a;
            color: #e0e0e0;
            font-family: inherit;
            touch-action: manipulation;
        }

        .controls select,
        .controls input,
        .controls button {
            font-size: 16px;
            min-height: 44px;
        }

        .btn-large {
            font-size: 18px;
            min-height: 44px;
            padding: 10px 20px;
        }

        @media (max-width: 480px) {
            .btn-large {
                width: 100%;
                display: block;
            }
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #ff6b6b;
        }
        
        button {
            background-color: #ff6b6b;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #ff5252;
        }
        
        button:active {
            background-color: #e53935;
        }
        
        .grid-container {
            text-align: center;
            margin: 30px 0;
        }
        
        .grid {
            display: inline-block;
            border: 2px solid #555;
            border-radius: 8px;
            background-color: #2a2a2a;
            padding: 15px;
            transition: background-color 0.3s;
            touch-action: none;
        }

        .grid.flash {
            background-color: #ff6b6b;
        }
        
        .grid-row {
            margin: 2px 0;
            touch-action: none;
        }
        
        .grid-cell {
            display: inline-block;
            width: var(--cell-size);
            height: var(--cell-size);
            line-height: var(--cell-size);
            margin: 1px;
            background-color: #4a4a4a;
            border: 1px solid #666;
            text-align: center;
            font-weight: bold;
            font-size: var(--cell-size);
            border-radius: 3px;
            touch-action: none;
        }
        
        .grid-cell.highlighted {
            background-color: #ff6b6b;
            color: white;
            box-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
            border-color: #ff8a80;
        }

        .grid-cell.selecting {
            background-color: #ffd54f;
            color: #000;
        }

        .grid-cell.correct {
            background-color: #4caf50;
            color: #fff;
        }

        .grid-cell.incorrect {
            background-color: #f44336;
            color: #fff;
        }

        .grid-cell.reveal {
            background: #e53935 !important;
            color: #fff !important;
            box-shadow: 0 0 8px rgba(229,57,53,0.9);
        }
        
        .game-section {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background-color: #3a3a3a;
            border-radius: 8px;
        }
        
        .guess-input {
            font-size: 18px;
            width: 100px;
            text-align: center;
            margin: 0 10px;
        }
        
        .result {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
            min-height: 30px;
        }
        
        .result.correct {
            color: #4caf50;
        }
        
        .result.incorrect {
            color: #ff5722;
        }
        
        .match-list {
            text-align: left;
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 14px;
        }
        
        .match-item {
            margin: 5px 0;
            padding: 5px;
            background-color: #3a3a3a;
            border-radius: 4px;
        }
        
        .instructions {
            background-color: #3a3a3a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .instructions h3 {
            color: #ff6b6b;
            margin-top: 0;
        }
        
        .instructions ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .instructions li {
            margin: 8px 0;
        }

        .arcade-hud {
            text-align: center;
            margin-bottom: 20px;
        }

        .arcade-timer {
            width: 100%;
            height: 10px;
            background-color: #555;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
            display: none;
        }

        .arcade-timer-inner {
            height: 100%;
            width: 100%;
            background-color: #ff6b6b;
        }

        .big-button {
            width: 100%;
            padding: 15px;
            font-size: 20px;
            margin-top: 10px;
            display: none;
        }

        .game-over-screen {
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>HowManyFucks</h1>
        <div class="subtitle">Find hidden instances of "FUCK" in the grid</div>
        
        <div id="basicInstructions" class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li>Look at the grid of F, U, C, K letters</li>
                <li>Count how many times "FUCK" appears in all 8 directions</li>
                <li>Words can overlap and run backwards (KCUF counts too)</li>
                <li>Enter your guess and click "Submit Guess"</li>
                <li>Use "Reveal Matches" to see all hidden words highlighted</li>
            </ul>
        </div>

        <div id="arcadeInstructions" class="instructions">
            <h3>Arcade Mode: The Hunt for the One True FUCK</h3>
            <ul>
                <li>A single fuck is given… unless it isn’t.</li>
                <li>Spot it quick to rise through the levels.</li>
                <li>Think there are none? Smash "No Fucks Given."</li>
                <li>Three lives only. Out of fucks, out of luck.</li>
                <li>There may be something else to look for, who knows?</li>
            </ul>
        </div>

        <button id="toggleControls" class="btn-large">Hide Controls</button>

        <div class="controls">
            <div class="control-group">
                <label for="gridSize">Grid Size:</label>
                <select id="gridSize">
                    <option value="8">8x8</option>
                    <option value="10" selected>10x10</option>
                    <option value="15">15x15</option>
                    <option value="20">20x20</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="minCount">Min Count:</label>
                <input type="number" id="minCount" value="0" min="0" max="10">
            </div>
            
            <div class="control-group">
                <label for="maxCount">Max Count:</label>
                <input type="number" id="maxCount" value="5" min="0" max="10">
            </div>
            
            <div class="control-group">
                <label for="seedInput">Seed (optional):</label>
                <input type="text" id="seedInput" placeholder="Enter seed...">
            </div>
            
            <div class="control-group">
                <label>&nbsp;</label>
                <button class="btn-large" onclick="generateNewPuzzle()">New Puzzle</button>
            </div>
            
            <div class="control-group">
                <label>&nbsp;</label>
                <button class="btn-large" onclick="generateDailyPuzzle()">Daily Puzzle</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button class="btn-large" onclick="startArcadeMode()">Arcade Mode</button>
            </div>
        </div>

        <div id="arcadeHud" class="arcade-hud" style="display:none;">
            <div id="arcadeLevel">Level 1</div>
            <div id="arcadeScore">Score: 0</div>
            <div id="arcadeLives">Lives: ❤❤❤</div>
        </div>

        <div class="grid-container">
            <div id="arcadeTimer" class="arcade-timer"><div id="arcadeTimerInner" class="arcade-timer-inner"></div></div>
            <div id="gameGrid" class="grid"></div>
            <button id="noFucksButton" class="big-button" style="display:none;">No Fucks Given</button>
        </div>
        
        <div class="game-section">
            <div>
                <label for="guessInput">Your guess:</label>
                <input type="number" id="guessInput" class="guess-input" min="0" max="50">
                <button class="btn-large" onclick="submitGuess()">Submit Guess</button>
                <button class="btn-large" onclick="revealMatches()">Reveal Matches</button>
            </div>
            
            <div id="result" class="result"></div>
            
            <div id="matchList" class="match-list" style="display: none;"></div>
        </div>
    </div>

    <script>
        // Game state
        let currentPuzzle = null;
        let revealed = false;
        let arcadeState = {
            active: false,
            level: 1,
            score: 0,
            lives: 3,
            roundEndsAt: null,
            timer: null,
            currentPuzzle: null
        };

        function updateArcadeHud() {
            document.getElementById('arcadeLevel').textContent = `Level ${arcadeState.level}`;
            document.getElementById('arcadeScore').textContent = `Score: ${arcadeState.score}`;
            document.getElementById('arcadeLives').innerHTML = `Lives: ${'❤'.repeat(arcadeState.lives)}`;
        }

        // Selection state for interactive highlighting
        let selecting = false;
        let selectionCells = [];
        let selectionDir = null;
        let activePointerId = null;
        let inputLocked = false;

        // Directions for word search
        const DIRECTIONS = {
            'N': [-1, 0], 'NE': [-1, 1], 'E': [0, 1], 'SE': [1, 1],
            'S': [1, 0], 'SW': [1, -1], 'W': [0, -1], 'NW': [-1, -1]
        };

        const TARGET_WORD = "FUCK";
        const LETTERS = ['F', 'U', 'C', 'K'];

        // Simple hash function for string seeds
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }

        // Simple seedable random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }

            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646;
            }

            randInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[this.randInt(0, array.length - 1)];
            }
        }

        function generateGrid(size, minCount, maxCount, seed = null) {
            const rng = seed ? new SeededRandom(hashString(seed.toString())) : new SeededRandom(Date.now());
            
            // Determine target count
            const targetCount = rng.randInt(minCount, maxCount);
            
            // Create empty grid
            const grid = Array(size).fill().map(() => Array(size).fill(null));
            const matches = [];
            
            // Place target words
            for (let i = 0; i < targetCount; i++) {
                if (!placeWord(grid, size, rng, matches)) {
                    break; // Failed to place word
                }
            }
            
            // Fill remaining cells
            fillGrid(grid, size, rng);
            
            // Scan for actual count
            const scanResult = scanGrid(grid);
            
            return {
                grid: grid,
                trueCount: scanResult.count,
                matches: scanResult.matches,
                targetCount: targetCount
            };
        }

        function placeWord(grid, size, rng, matches) {
            const maxAttempts = 1000;
            const dirNames = Object.keys(DIRECTIONS);
            
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const row = rng.randInt(0, size - 1);
                const col = rng.randInt(0, size - 1);
                const dirName = rng.choice(dirNames);
                const [dr, dc] = DIRECTIONS[dirName];
                
                // Check bounds
                const endRow = row + dr * (TARGET_WORD.length - 1);
                const endCol = col + dc * (TARGET_WORD.length - 1);
                
                if (endRow < 0 || endRow >= size || endCol < 0 || endCol >= size) {
                    continue;
                }
                
                // Check if we can place the word
                const cells = [];
                let canPlace = true;
                
                for (let i = 0; i < TARGET_WORD.length; i++) {
                    const r = row + dr * i;
                    const c = col + dc * i;
                    cells.push([r, c]);
                    
                    if (grid[r][c] !== null && grid[r][c] !== TARGET_WORD[i]) {
                        canPlace = false;
                        break;
                    }
                }
                
                if (canPlace) {
                    // Place the word
                    for (let i = 0; i < TARGET_WORD.length; i++) {
                        const r = row + dr * i;
                        const c = col + dc * i;
                        grid[r][c] = TARGET_WORD[i];
                    }
                    
                    matches.push({
                        start: [row, col],
                        direction: dirName,
                        cells: cells
                    });
                    
                    return true;
                }
            }
            
            return false;
        }

        function fillGrid(grid, size, rng) {
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (grid[row][col] === null) {
                        grid[row][col] = rng.choice(LETTERS);
                    }
                }
            }
        }

        function scanGrid(grid) {
            const size = grid.length;
            const matches = [];
            const foundMatches = new Set();

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    for (const [dirName, [dr, dc]] of Object.entries(DIRECTIONS)) {
                        const match = checkWordAtPosition(grid, row, col, dr, dc);
                        if (match) {
                            const matchKey = match.map(([r, c]) => `${r},${c}`).sort().join('|');
                            if (!foundMatches.has(matchKey)) {
                                foundMatches.add(matchKey);
                                matches.push({
                                    start: [row, col],
                                    direction: dirName,
                                    cells: match
                                });
                            }
                        }
                    }
                }
            }

            return { count: matches.length, matches: matches };
        }

        function checkWordAtPosition(grid, startRow, startCol, dr, dc) {
            const size = grid.length;
            const cells = [];
            let word = "";

            for (let i = 0; i < TARGET_WORD.length; i++) {
                const r = startRow + dr * i;
                const c = startCol + dc * i;

                if (r < 0 || r >= size || c < 0 || c >= size) {
                    return null;
                }

                cells.push([r, c]);
                word += grid[r][c];
            }

            return word === TARGET_WORD ? cells : null;
        }

        function renderGrid(grid, highlightedCells = new Set()) {
            const gridElement = document.getElementById('gameGrid');
            gridElement.innerHTML = '';
            gridElement.style.userSelect = 'none';

            for (let row = 0; row < grid.length; row++) {
                const rowElement = document.createElement('div');
                rowElement.className = 'grid-row';

                for (let col = 0; col < grid[row].length; col++) {
                    const cellElement = document.createElement('span');
                    cellElement.className = 'grid-cell';
                    cellElement.textContent = grid[row][col];
                    cellElement.dataset.row = row;
                    cellElement.dataset.col = col;

                    const cellKey = `${row},${col}`;
                    if (highlightedCells.has(cellKey)) {
                        cellElement.classList.add('highlighted');
                    }

                    rowElement.appendChild(cellElement);
                }

                gridElement.appendChild(rowElement);
            }

            const vw = Math.min(window.innerWidth, 800) * 0.92;
            const size = grid.length;
            const cell = Math.max(24, Math.floor(vw / (size + 2)));
            document.documentElement.style.setProperty('--cell-size', cell + 'px');
        }

        function onGridPointerDown(e) {
            if (inputLocked) return;
            if (!e.target.classList.contains('grid-cell')) return;
            e.preventDefault();
            selecting = true;
            activePointerId = e.pointerId;
            selectionCells = [e.target];
            selectionDir = null;
            e.currentTarget.setPointerCapture(activePointerId);
            e.target.classList.add('selecting');
        }

        function onGridPointerMove(e) {
            if (!selecting || e.pointerId !== activePointerId) return;
            e.preventDefault();
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (!el || !el.classList || !el.classList.contains('grid-cell')) return;
            if (selectionCells.includes(el)) return;
            const r = parseInt(el.dataset.row);
            const c = parseInt(el.dataset.col);
            const lastCell = selectionCells[selectionCells.length - 1];
            const lr = parseInt(lastCell.dataset.row);
            const lc = parseInt(lastCell.dataset.col);
            const dr = r - lr;
            const dc = c - lc;
            if (Math.abs(dr) > 1 || Math.abs(dc) > 1) return;

            if (selectionCells.length === 1) {
                selectionDir = { dr, dc };
            } else {
                if (!selectionDir || dr !== selectionDir.dr || dc !== selectionDir.dc) return;
            }

            selectionCells.push(el);
            el.classList.add('selecting');
            if (selectionCells.length > 4) {
                const removed = selectionCells.splice(4);
                removed.forEach(cell => cell.classList.remove('selecting'));
            }
        }

        function onGridPointerUp(e) {
            if (!selecting || e.pointerId !== activePointerId) return;
            e.preventDefault();
            e.currentTarget?.releasePointerCapture?.(activePointerId);
            evaluateSelection();
            cleanupSelectionState();
        }

        function onGridPointerCancel(e) {
            if (!selecting || e.pointerId !== activePointerId) return;
            e.preventDefault();
            e.currentTarget?.releasePointerCapture?.(activePointerId);
            evaluateSelection();
            cleanupSelectionState();
        }

        function evaluateSelection() {
            if (inputLocked) return;
            const n = selectionCells.length;
            if (n !== 4) {
                selectionCells.forEach(cell => {
                    cell.classList.add('incorrect');
                });
                setTimeout(() => {
                    selectionCells.forEach(cell => cell.classList.remove('incorrect'));
                }, 400);
                return;
            }

            const letters = selectionCells.map(cell => cell.textContent).join('');
            const reversed = letters.split('').reverse().join('');
            const isCorrect = letters === TARGET_WORD || reversed === TARGET_WORD;

            if (isCorrect) {
                selectionCells.forEach(cell => {
                    cell.classList.remove('selecting');
                    cell.classList.add('correct');
                });
                endArcadeRound('success');
            } else {
                selectionCells.forEach(cell => cell.classList.add('incorrect'));
                setTimeout(() => {
                    selectionCells.forEach(cell => cell.classList.remove('incorrect'));
                }, 500);
            }
        }

        function cleanupSelectionState() {
            selecting = false;
            activePointerId = null;
            selectionDir = null;
            selectionCells.forEach(cell => {
                if (!cell.classList.contains('correct')) {
                    cell.classList.remove('selecting');
                }
            });
            selectionCells = [];
        }

        const gameGrid = document.getElementById('gameGrid');
        gameGrid.addEventListener('pointerdown', onGridPointerDown, { passive: false });
        gameGrid.addEventListener('pointermove', onGridPointerMove, { passive: false });
        gameGrid.addEventListener('pointerup', onGridPointerUp, { passive: false });
        gameGrid.addEventListener('pointercancel', onGridPointerCancel, { passive: false });
        window.addEventListener('pointerup', onGridPointerUp, { passive: false });
        window.addEventListener('pointercancel', onGridPointerCancel, { passive: false });
        gameGrid.addEventListener('touchmove', (e) => { if (arcadeState.active) e.preventDefault(); }, {passive: false});
        gameGrid.addEventListener('wheel', (e) => { if (arcadeState.active) e.preventDefault(); }, {passive: false});

        function renderMatchList(matches) {
            const matchListElement = document.getElementById('matchList');
            
            if (matches.length === 0) {
                matchListElement.innerHTML = '<div>No matches found.</div>';
                return;
            }

            let html = '<h4>Matches found:</h4>';
            matches.forEach((match, index) => {
                const [startRow, startCol] = match.start;
                const cellsStr = match.cells.map(([r, c]) => `(${r+1},${c+1})`).join(',');
                html += `<div class="match-item">#${index+1}: start=(row ${startRow+1}, col ${startCol+1}), dir=${match.direction}, cells=[${cellsStr}]</div>`;
            });

            matchListElement.innerHTML = html;
        }

        function generateNewPuzzle() {
            const size = parseInt(document.getElementById('gridSize').value);
            const minCount = parseInt(document.getElementById('minCount').value);
            const maxCount = parseInt(document.getElementById('maxCount').value);
            const seed = document.getElementById('seedInput').value || null;

            currentPuzzle = generateGrid(size, minCount, maxCount, seed);
            revealed = false;

            renderGrid(currentPuzzle.grid);
            
            document.getElementById('result').textContent = '';
            document.getElementById('matchList').style.display = 'none';
            document.getElementById('guessInput').value = '';
        }

        function generateDailyPuzzle() {
            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
            const dailySeed = `hmf-${today}`;
            
            document.getElementById('seedInput').value = dailySeed;
            document.getElementById('gridSize').value = '10';
            document.getElementById('minCount').value = '0';
            document.getElementById('maxCount').value = '5';
            
            generateNewPuzzle();
        }

        function submitGuess() {
            if (!currentPuzzle) {
                alert('Generate a puzzle first!');
                return;
            }

            const guess = parseInt(document.getElementById('guessInput').value);
            if (isNaN(guess) || guess < 0) {
                alert('Please enter a valid non-negative number.');
                return;
            }

            const resultElement = document.getElementById('result');
            const trueCount = currentPuzzle.trueCount;

            if (guess === trueCount) {
                resultElement.textContent = `Correct! There were ${trueCount} FUCK(s).`;
                resultElement.className = 'result correct';
            } else {
                resultElement.textContent = `Not quite. The correct count is ${trueCount}.`;
                resultElement.className = 'result incorrect';
            }
        }

        function revealMatches() {
            if (!currentPuzzle) {
                alert('Generate a puzzle first!');
                return;
            }

            if (revealed) return;

            const highlightedCells = new Set();
            currentPuzzle.matches.forEach(match => {
                match.cells.forEach(([r, c]) => {
                    highlightedCells.add(`${r},${c}`);
                });
            });

            renderGrid(currentPuzzle.grid, highlightedCells);
            renderMatchList(currentPuzzle.matches);

            document.getElementById('matchList').style.display = 'block';
            revealed = true;
        }

        function flashTrueMatch(ms = 900) {
            const p = arcadeState?.currentPuzzle;
            if (!p?.matches?.length) return Promise.resolve();
            const cells = p.matches[0].cells || [];
            const els = [];
            const grid = document.getElementById('gameGrid');
            cells.forEach(([r, c]) => {
                const el = grid.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (el) {
                    el.classList.add('reveal');
                    els.push(el);
                }
            });
            console.log('flashTrueMatch found:', els.length);
            return new Promise(resolve => {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            els.forEach(el => el.classList.remove('reveal'));
                            resolve();
                        }, ms);
                    });
                });
            });
        }

        function startArcadeMode() {
            arcadeState.active = true;
            arcadeState.level = 1;
            arcadeState.score = 0;
            arcadeState.lives = 3;
            arcadeState.roundEndsAt = null;
            arcadeState.currentPuzzle = null;

            updateArcadeHud();

            setControlsVisibility(false);
            document.querySelector('.game-section').style.display = 'none';
            document.getElementById('basicInstructions').style.display = 'none';
            document.getElementById('arcadeInstructions').style.display = 'block';

            document.getElementById('arcadeHud').style.display = 'block';
            document.getElementById('arcadeTimer').style.display = 'block';
            document.getElementById('noFucksButton').style.display = 'block';

            startArcadeRound();
        }

        function startArcadeRound() {
            if (!arcadeState.active) return;

            inputLocked = false;
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('selecting', 'incorrect');
            });
            cleanupSelectionState();

            const size = Math.min(4 + arcadeState.level - 1, 20);
            const puzzle = generateGrid(size, 1, 1);
            arcadeState.currentPuzzle = puzzle;
            currentPuzzle = puzzle;
            console.log('matches:', arcadeState.currentPuzzle?.matches?.length);
            renderGrid(puzzle.grid);

            const timeBudget = Math.max(7000, Math.min(6000 + 400 * size, 18000));
            arcadeState.roundEndsAt = Date.now() + timeBudget;

            const timerInner = document.getElementById('arcadeTimerInner');
            timerInner.style.width = '100%';

            if (arcadeState.timer) clearInterval(arcadeState.timer);
            arcadeState.timer = setInterval(() => {
                const remaining = arcadeState.roundEndsAt - Date.now();
                const percent = Math.max(0, remaining / timeBudget * 100);
                timerInner.style.width = percent + '%';
                if (remaining <= 0) {
                    clearInterval(arcadeState.timer);
                    arcadeState.timer = null;
                    endArcadeRound('timeout');
                }
            }, 100);

            updateArcadeHud();
        }

        async function endArcadeRound(reason) {
            inputLocked = true;
            if (!arcadeState.roundEndsAt) return;

            if (arcadeState.timer) {
                clearInterval(arcadeState.timer);
                arcadeState.timer = null;
            }

            const gridElement = document.getElementById('gameGrid');

            if (reason === 'success') {
                cleanupSelectionState();
                arcadeState.level += 1;
                const remaining = arcadeState.roundEndsAt - Date.now();
                arcadeState.score += Math.max(0, Math.floor(remaining / 1000));
                arcadeState.roundEndsAt = null;
                updateArcadeHud();
                setTimeout(() => {
                    if (arcadeState.active && arcadeState.lives > 0) {
                        startArcadeRound();
                    }
                }, 200);
                return;
            }

            await flashTrueMatch();
            cleanupSelectionState();
            gridElement.classList.add('flash');
            setTimeout(() => {
                gridElement.classList.remove('flash');
                arcadeState.lives -= 1;
                if (arcadeState.lives <= 0) {
                    updateArcadeHud();
                    arcadeState.roundEndsAt = null;
                    setTimeout(() => gameOver(), 300);
                    return;
                } else {
                    arcadeState.level += 1;
                }
                arcadeState.roundEndsAt = null;
                updateArcadeHud();
                setTimeout(() => {
                    if (arcadeState.active && arcadeState.lives > 0) {
                        startArcadeRound();
                    }
                }, 300);
            }, 200);
        }

        function gameOver() {
            if (arcadeState.timer) {
                clearInterval(arcadeState.timer);
                arcadeState.timer = null;
            }
            arcadeState.active = false;

            const gridElement = document.getElementById('gameGrid');
            gridElement.innerHTML = `<div class="game-over-screen"><h2>Game Over</h2><p>Level reached: ${arcadeState.level}</p><p>Score: ${arcadeState.score}</p><button id="playAgainButton">Play Again</button></div>`;

            document.getElementById('arcadeHud').style.display = 'none';
            document.getElementById('arcadeTimer').style.display = 'none';
            document.getElementById('noFucksButton').style.display = 'none';
            document.getElementById('arcadeInstructions').style.display = 'none';

        document.getElementById('playAgainButton').addEventListener('click', () => {
                arcadeState.active = false;
                arcadeState.level = 1;
                arcadeState.score = 0;
                arcadeState.lives = 3;
                arcadeState.roundEndsAt = null;
                arcadeState.timer = null;
                arcadeState.currentPuzzle = null;

                document.getElementById('arcadeHud').style.display = 'none';
                document.getElementById('arcadeTimer').style.display = 'none';
                document.getElementById('noFucksButton').style.display = 'none';

                setControlsVisibility(window.innerWidth >= 600);
                document.querySelector('.game-section').style.display = 'block';
                document.getElementById('arcadeInstructions').style.display = 'none';
                document.getElementById('basicInstructions').style.display = 'block';

                generateNewPuzzle();
            });
        }

        const controlsElement = document.querySelector('.controls');
        const toggleControlsButton = document.getElementById('toggleControls');

        function setControlsVisibility(show) {
            controlsElement.style.display = show ? 'grid' : 'none';
            toggleControlsButton.textContent = show ? 'Hide Controls' : 'Show Controls';
        }

        function initControlsToggle() {
            setControlsVisibility(window.innerWidth >= 600);
        }

        toggleControlsButton.addEventListener('click', () => {
            const isHidden = controlsElement.style.display === 'none' || controlsElement.style.display === '';
            setControlsVisibility(isHidden);
        });

        window.addEventListener('resize', () => {
            setControlsVisibility(window.innerWidth >= 600);
        });

        // Initialize with a puzzle
        window.addEventListener('load', () => {
            initControlsToggle();
            generateNewPuzzle();
        });

        // Handle Enter key in guess input
        document.getElementById('guessInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitGuess();
            }
        });

        document.getElementById('noFucksButton').addEventListener('click', () => {
            if (arcadeState.active && arcadeState.roundEndsAt) {
                if (arcadeState.currentPuzzle?.matches?.length) {
                    endArcadeRound('fail');
                } else {
                    endArcadeRound('success');
                }
            }
        });
    </script>
</body>
</html>
